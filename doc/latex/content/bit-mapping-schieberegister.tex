% =============================================================================
% bit-mapping-schieberegister.tex – Schieberegister verstehen
% =============================================================================

\section{Bit-Mapping – Schieberegister verstehen}

\subsection{Begriffsrahmen und Zielsetzung}

Das Selection Panel verwendet Schieberegister, um 10–100 Buttons und LEDs mit wenigen GPIO-Pins anzusteuern. Die zentrale Herausforderung: Wie ordnen wir eine Button-ID (\zB \glqq Button 7\grqq) einem konkreten Bit in einem Byte-Array zu?

\begin{table}[htbp]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Begriff} & \textbf{Definition} \\
\midrule
Bit-Mapping  & Zuordnungsregel zwischen logischer ID und physischer Bit-Position \\
MSB-first    & Most Significant Bit first – Bit 7 wird zuerst übertragen/gelesen \\
Active-Low   & Logisch aktiv bei Pegel 0 (GND) \\
Active-High  & Logisch aktiv bei Pegel 1 (VCC) \\
One-Hot      & Genau ein Bit gesetzt, alle anderen 0 \\
Kaskadierung & Mehrere ICs in Reihe geschaltet (Daisy-Chain) \\
\bottomrule
\end{tabular}
\caption{Begriffsrahmen Bit-Mapping}
\label{tab:bitmapping-begriffe}
\end{table}

\textbf{Ziel:} Eindeutige, skalierbare Zuordnung von IDs zu Bits – funktioniert identisch für 10 wie für 100 Kanäle.

% -----------------------------------------------------------------------------
\subsection{Das Grundproblem – IDs vs. Bytes}

\textbf{Problem:} Die Firmware-Logik arbeitet mit Button-IDs (1, 2, 3, \ldots, 100). Die Hardware arbeitet mit Byte-Arrays. Zwischen beiden muss eine eindeutige Übersetzung existieren.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    box/.style={draw, fill=CodeBg, minimum width=3.5cm, minimum height=0.8cm,
                font=\ttfamily\small, rounded corners=2pt},
    arr/.style={-{Stealth[length=2mm]}, thick, color=ArduinoDark}
]
\node[box] (logic) at (0,2) {selectedId = 7};
\node[font=\small\sffamily, color=MutedText] (map) at (0,1) {[Bit-Mapping]};
\node[box] (hw) at (0,0) {ledState[0]=0x02, [1]=0x00};
\draw[arr] (logic.south) -- (map.north);
\draw[arr] (map.south) -- (hw.north);
\end{tikzpicture}
\caption{Übersetzung zwischen Logik-IDs und Hardware-Bytes}
\label{fig:id-byte-mapping}
\end{figure}

\textbf{Regel:} IDs sind 1-basiert (1..N), Bytes sind 0-basiert (0..bytes-1), Bits sind 0–7.

\textbf{Byte-Anzahl berechnen:}

\begin{lstlisting}[style=arduino,numbers=none]
bytes = (count + 7) / 8
\end{lstlisting}

\begin{table}[htbp]
\centering
\begin{tabular}{@{}llr@{}}
\toprule
\textbf{Kanäle} & \textbf{Rechnung} & \textbf{Bytes} \\
\midrule
8   & (8+7)/8 = 1    & 1 \\
10  & (10+7)/8 = 2   & 2 \\
16  & (16+7)/8 = 2   & 2 \\
100 & (100+7)/8 = 13 & 13 \\
\bottomrule
\end{tabular}
\caption{Byte-Anzahl für verschiedene Kanalzahlen}
\label{tab:byte-anzahl}
\end{table}

\textbf{Konsequenz:} Die Logik kennt nur IDs. Die Treiber kennen nur Bytes. Das Bit-Mapping ist die Brücke dazwischen.

% -----------------------------------------------------------------------------
\subsection{MSB-first – Warum Bit 7 zuerst?}

\textbf{Problem:} Bei SPI-Kommunikation gibt es zwei Konventionen: MSB-first (Bit 7 zuerst) oder LSB-first (Bit 0 zuerst). Die Wahl beeinflusst das gesamte Mapping.

\textbf{Entscheidung im Projekt:} MSB-first für beide Schieberegister-Typen.

\textbf{Warum MSB-first?} Wenn wir die Bytes in der Reihenfolge senden, wie sie im Array stehen, und MSB-first verwenden, ergibt sich eine intuitive Zuordnung:

\begin{lstlisting}[style=wrap,numbers=none]
Array:     [Byte 0] [Byte 1] [Byte 2] ...
Bits:      76543210 76543210 76543210 ...
IDs:       12345678 9...16   17...24  ...
\end{lstlisting}

Die erste ID (1) landet im höchstwertigen Bit (7) des ersten Bytes (0). Das ist leicht nachvollziehbar und debugbar.

\textbf{Mapping-Formel (für ID 1..N):}

\begin{lstlisting}[style=arduino]
byte_index = (id - 1) / 8
bit_position = 7 - ((id - 1) % 8)
mask = 1 << bit_position
\end{lstlisting}

\textbf{Herleitung am Beispiel:}

Für ID = 7:
\begin{itemize}
\item \code{byte\_index = (7-1) / 8 = 0} → Byte 0
\item \code{bit\_position = 7 - ((7-1) \% 8) = 7 - 6 = 1} → Bit 1
\item \code{mask = 1 << 1 = 0x02}
\end{itemize}

Für ID = 9:
\begin{itemize}
\item \code{byte\_index = (9-1) / 8 = 1} → Byte 1
\item \code{bit\_position = 7 - ((9-1) \% 8) = 7 - 0 = 7} → Bit 7
\item \code{mask = 1 << 7 = 0x80}
\end{itemize}

% -----------------------------------------------------------------------------
\subsection{Buttons (CD4021) – Active-Low lesen}

\textbf{Funktionsweise:} Der CD4021 ist ein Parallel-zu-Seriell-Wandler. Er liest 8 parallele Eingänge und schiebt sie seriell zum ESP32.

\textbf{Active-Low bedeutet:}

\begin{table}[htbp]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Physischer Zustand} & \textbf{Pegel am Pin} & \textbf{Bit-Wert} \\
\midrule
Button losgelassen & HIGH (Pullup)  & \code{1} \\
Button gedrückt    & LOW (nach GND) & \code{0} \\
\bottomrule
\end{tabular}
\caption{Active-Low-Logik beim CD4021}
\label{tab:active-low}
\end{table}

\begin{infobox}[Idle-Erwartung]
Wenn kein Button gedrückt ist, liest du \code{0xFF} pro Byte (alle Bits = 1).
\end{infobox}

\textbf{Mapping-Tabelle (10 Buttons):}

\begin{table}[htbp]
\centering
\begin{tabular}{@{}rrrll@{}}
\toprule
\textbf{ID} & \textbf{Byte} & \textbf{Bit} & \textbf{Maske} & \textbf{Gedrückt =} \\
\midrule
1  & 0 & 7 & \code{0x80} & Bit 7 = 0 \\
2  & 0 & 6 & \code{0x40} & Bit 6 = 0 \\
3  & 0 & 5 & \code{0x20} & Bit 5 = 0 \\
4  & 0 & 4 & \code{0x10} & Bit 4 = 0 \\
5  & 0 & 3 & \code{0x08} & Bit 3 = 0 \\
6  & 0 & 2 & \code{0x04} & Bit 2 = 0 \\
7  & 0 & 1 & \code{0x02} & Bit 1 = 0 \\
8  & 0 & 0 & \code{0x01} & Bit 0 = 0 \\
9  & 1 & 7 & \code{0x80} & Bit 7 = 0 \\
10 & 1 & 6 & \code{0x40} & Bit 6 = 0 \\
\bottomrule
\end{tabular}
\caption{Bit-Mapping für 10 Buttons (MSB-first)}
\label{tab:button-mapping}
\end{table}

\textbf{Beispiel – Button 3 gedrückt:}

\begin{lstlisting}[style=arduino,numbers=none]
Byte 0: 0b11011111 = 0xDF  (Bit 5 = 0)
Byte 1: 0b11111111 = 0xFF  (keine Aenderung)
\end{lstlisting}

\textbf{Prüfung im Code:}

\begin{lstlisting}[style=arduino]
bool isPressed(uint8_t id, const uint8_t* raw) {
    uint8_t byteIdx = (id - 1) / 8;
    uint8_t bitPos  = 7 - ((id - 1) % 8);
    uint8_t mask    = 1 << bitPos;

    // Active-low: gedrueckt wenn Bit = 0
    return (raw[byteIdx] & mask) == 0;
}
\end{lstlisting}

% -----------------------------------------------------------------------------
\subsection{LEDs (74HC595) – Active-High schreiben}

\textbf{Funktionsweise:} Der 74HC595 ist ein Seriell-zu-Parallel-Wandler. Er empfängt Daten seriell vom ESP32 und gibt sie parallel an 8 Ausgänge aus.

\textbf{Active-High bedeutet:}

\begin{table}[htbp]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Gewünschter Zustand} & \textbf{Bit-Wert} & \textbf{Ergebnis} \\
\midrule
LED aus & \code{0} & Ausgang LOW \\
LED an  & \code{1} & Ausgang HIGH \\
\bottomrule
\end{tabular}
\caption{Active-High-Logik beim 74HC595}
\label{tab:active-high}
\end{table}

\textbf{Mapping-Tabelle (identisch zu Buttons):}

\begin{table}[htbp]
\centering
\begin{tabular}{@{}rrrll@{}}
\toprule
\textbf{ID} & \textbf{Byte} & \textbf{Bit} & \textbf{Maske} & \textbf{LED an =} \\
\midrule
1  & 0 & 7 & \code{0x80} & \code{0x80 0x00} \\
2  & 0 & 6 & \code{0x40} & \code{0x40 0x00} \\
\ldots & \ldots & \ldots & \ldots & \ldots \\
8  & 0 & 0 & \code{0x01} & \code{0x01 0x00} \\
9  & 1 & 7 & \code{0x80} & \code{0x00 0x80} \\
10 & 1 & 6 & \code{0x40} & \code{0x00 0x40} \\
\bottomrule
\end{tabular}
\caption{Bit-Mapping für 10 LEDs (MSB-first)}
\label{tab:led-mapping}
\end{table}

\textbf{One-Hot-Ausgabe:}

\begin{lstlisting}[style=arduino]
void setOneHot(uint8_t selectedId, uint8_t* ledState, size_t bytes) {
    // 1. Alle LEDs aus
    memset(ledState, 0x00, bytes);

    // 2. Genau eine LED setzen (wenn ID > 0)
    if (selectedId >= 1 && selectedId <= LED_COUNT) {
        uint8_t byteIdx = (selectedId - 1) / 8;
        uint8_t bitPos  = 7 - ((selectedId - 1) % 8);
        ledState[byteIdx] |= (1 << bitPos);
    }
}
\end{lstlisting}

\textbf{Beispiel – LED 9 an:}

\begin{lstlisting}[style=arduino,numbers=none]
Byte 0: 0b00000000 = 0x00
Byte 1: 0b10000000 = 0x80  (Bit 7 = 1)
\end{lstlisting}

% -----------------------------------------------------------------------------
\subsection{Last-Byte-Maskierung – Ungültige Bits behandeln}

\textbf{Problem:} Bei 10 Kanälen brauchst du 2 Bytes (16 Bits), aber nur 10 sind gültig. Die Bits 5–0 im zweiten Byte sind \glqq überzählig\grqq. Wenn sie durch Speicherfehler oder Bugs gesetzt werden, könnte das System falsch reagieren.

\textbf{Regel:} Ungültige Bits müssen maskiert werden – bei Buttons auf 1 (idle), bei LEDs auf 0 (aus).

\textbf{Berechnung der Maske:}

\begin{lstlisting}[style=arduino]
uint8_t valid_bits = count % 8;
if (valid_bits == 0) valid_bits = 8;  // Volle 8 Bits

// MSB-first: die obersten valid_bits sind gueltig
uint8_t LAST_MASK = 0xFF << (8 - valid_bits);
\end{lstlisting}

\textbf{Beispiele:}

\begin{table}[htbp]
\centering
\begin{tabular}{@{}rrlll@{}}
\toprule
\textbf{Count} & \textbf{valid\_bits} & \textbf{LAST\_MASK} & \textbf{Binär} & \textbf{Gültige Bits} \\
\midrule
8   & 8 & \code{0xFF} & \code{11111111} & alle \\
10  & 2 & \code{0xC0} & \code{11000000} & Bit 7, 6 \\
12  & 4 & \code{0xF0} & \code{11110000} & Bit 7, 6, 5, 4 \\
100 & 4 & \code{0xF0} & \code{11110000} & Bit 7, 6, 5, 4 \\
\bottomrule
\end{tabular}
\caption{Last-Byte-Masken für verschiedene Kanalzahlen}
\label{tab:last-mask}
\end{table}

\textbf{Anwendung:}

\begin{lstlisting}[style=arduino]
// Nach dem Lesen (Buttons): ungueltige Bits auf 1 setzen
raw[last_byte] |= ~BTN_LAST_MASK;

// Vor dem Schreiben (LEDs): ungueltige Bits auf 0 setzen
led[last_byte] &= LED_LAST_MASK;
\end{lstlisting}

\begin{warnbox}[Warum ist das wichtig?]
Bei 10 LEDs und \code{LAST\_MASK = 0xC0}: Wenn \code{led[1] = 0xFF} (durch Bug), würden nach Maskierung nur \code{led[1] = 0xC0} an den HC595 gehen. Ohne Maskierung: 6 \glqq Phantom-LEDs\grqq{} würden leuchten.
\end{warnbox}

% -----------------------------------------------------------------------------
\subsection{Kaskadierung – Mehrere ICs verketten}

\textbf{Problem:} Ein CD4021 oder 74HC595 hat nur 8 Kanäle. Für 10, 50 oder 100 Kanäle müssen mehrere ICs in Reihe geschaltet werden.

\paragraph{CD4021-Kette (Input)}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    ic/.style={draw, fill=CodeBg, minimum width=2.5cm, minimum height=1.5cm,
               font=\small, rounded corners=2pt, align=center},
    arr/.style={-{Stealth[length=2mm]}, thick, color=ArduinoDark},
    label/.style={font=\footnotesize\itshape, color=MutedText}
]
\node[ic] (ic1) at (0,0) {CD4021\\IC 1\\(ID 9–16)};
\node[ic] (ic0) at (4,0) {CD4021\\IC 0\\(ID 1–8)};
\node[ic] (esp) at (8,0) {ESP32\\MISO};

\draw[arr] (ic1.east) -- node[above, label] {Q} (ic0.west);
\draw[arr] (ic0.east) -- node[above, label] {Q} (esp.west);

\node[label, below=0.3cm of ic1] {Buttons 9–16};
\node[label, below=0.3cm of ic0] {Buttons 1–8};
\node[label, below=0.3cm of esp] {SCK, PS};
\end{tikzpicture}
\caption{CD4021-Kaskadierung für Button-Input}
\label{fig:cd4021-kette}
\end{figure}

\textbf{Reihenfolge:} Das erste gelesene Bit kommt vom IC, der direkt am ESP32 hängt (IC 0). Die Daten der kaskadierten ICs werden \glqq durchgeschoben\grqq.

\paragraph{74HC595-Kette (Output)}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    ic/.style={draw, fill=CodeBg, minimum width=2.5cm, minimum height=1.5cm,
               font=\small, rounded corners=2pt, align=center},
    arr/.style={-{Stealth[length=2mm]}, thick, color=ArduinoDark},
    label/.style={font=\footnotesize\itshape, color=MutedText}
]
\node[ic] (esp) at (0,0) {ESP32\\MOSI};
\node[ic] (ic0) at (4,0) {HC595\\IC 0\\(ID 1–8)};
\node[ic] (ic1) at (8,0) {HC595\\IC 1\\(ID 9–16)};

\draw[arr] (esp.east) -- (ic0.west);
\draw[arr] (ic0.east) -- node[above, label] {Q7'} (ic1.west);

\node[label, below=0.3cm of ic0] {LED 1–8};
\node[label, below=0.3cm of ic1] {LED 9–16};
\end{tikzpicture}
\caption{74HC595-Kaskadierung für LED-Output}
\label{fig:hc595-kette}
\end{figure}

\textbf{Reihenfolge:} Die zuerst gesendeten Bits landen im hintersten IC der Kette. Byte 0 geht an IC 0, Byte 1 an IC 1 usw.

\begin{warnbox}[Typischer Fehler]
Wenn die ICs falsch herum verkabelt sind, erscheinen die IDs \glqq gespiegelt\grqq{} – Button 1 löst LED 8 aus, Button 9 löst LED 16 aus.
\end{warnbox}

% -----------------------------------------------------------------------------
\subsection{Vollständiges Beispiel – Button 7 drücken}

Wir verfolgen den Datenfluss, wenn Button 7 gedrückt wird:

\textbf{1. Hardware-Zustand:}
\begin{lstlisting}[style=wrap,numbers=none]
Button 7 zieht Pin auf GND -> Bit 1 von Byte 0 wird 0
\end{lstlisting}

\textbf{2. CD4021 liest (2 Bytes):}
\begin{lstlisting}[style=arduino,numbers=none]
raw[0] = 0b11111101 = 0xFD  (Bit 1 = 0)
raw[1] = 0b11111111 = 0xFF
\end{lstlisting}

\textbf{3. Logik erkennt Button 7:}
\begin{lstlisting}[style=arduino]
id = 7
byteIdx = (7-1)/8 = 0
bitPos  = 7 - ((7-1) % 8) = 7 - 6 = 1
mask    = 0x02

// Pruefung: (raw[0] & 0x02) == 0?
// -> (0xFD & 0x02) = 0x00 -> JA, gedrueckt!
\end{lstlisting}

\textbf{4. Selection-Logik setzt} \code{selectedId = 7}

\textbf{5. One-Hot erzeugt LED-Bytes:}
\begin{lstlisting}[style=arduino]
led[0] = 0x00;  // clear
led[1] = 0x00;

// Set Bit fuer ID 7:
byteIdx = 0
bitPos  = 1
led[0] |= (1 << 1) = 0x02

// Ergebnis:
led[0] = 0b00000010 = 0x02
led[1] = 0b00000000 = 0x00
\end{lstlisting}

\textbf{6. HC595 schreibt:}
\begin{lstlisting}[style=wrap,numbers=none]
IC 0 erhaelt 0x02 -> Ausgang Q1 = HIGH -> LED 7 leuchtet
IC 1 erhaelt 0x00 -> alle Ausgaenge LOW
\end{lstlisting}

% -----------------------------------------------------------------------------
\subsection{Skalierung – 10 → 100 ohne Code-Änderung}

\textbf{Änderungen in} \code{io\_counts.h}:

\begin{lstlisting}[style=arduino]
// Vorher (10 Kanaele)
#define BTN_COUNT  10
#define LED_COUNT  10

// Nachher (100 Kanaele)
#define BTN_COUNT  100
#define LED_COUNT  100
\end{lstlisting}

\textbf{Automatisch abgeleitete Werte:}

\begin{table}[htbp]
\centering
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Parameter} & \textbf{10 Kanäle} & \textbf{100 Kanäle} \\
\midrule
\code{BTN\_BYTES}     & 2  & 13 \\
\code{LED\_BYTES}     & 2  & 13 \\
\code{BTN\_LAST\_MASK} & \code{0xC0} & \code{0xF0} \\
\code{LED\_LAST\_MASK} & \code{0xC0} & \code{0xF0} \\
\bottomrule
\end{tabular}
\caption{Automatisch abgeleitete Parameter bei Skalierung}
\label{tab:skalierung-bit-mapping}
\end{table}

\textbf{Keine Änderungen nötig in:}
\begin{itemize}
\item Bit-Mapping-Formeln (arbeiten mit beliebigen IDs)
\item Treiber-Code (iteriert über \code{*\_BYTES})
\item Logik-Code (arbeitet mit IDs, nicht Bytes)
\end{itemize}

\begin{tipbox}[Konsequenz]
Die Architektur ist skalierbar, solange die SSOT-Werte angepasst werden.
\end{tipbox}

% -----------------------------------------------------------------------------
\subsection{Fehlerbehebung}

\begin{table}[htbp]
\centering
\begin{tabularx}{\textwidth}{@{}lXl@{}}
\toprule
\textbf{Symptom} & \textbf{Wahrscheinliche Ursache} & \textbf{Diagnose} \\
\midrule
RAW = 0xFF (immer) & Pullups fehlen oder PS/LOAD-Signal falsch & Oszilloskop an PS/LOAD \\
RAW = 0x00 (immer) & Kurzschluss nach GND & Durchgangsprüfung \\
Falsche ID erkannt & MSB/LSB vertauscht oder Kaskadierung falsch & E2E-Test mit einzelnen Buttons \\
LEDs spiegelverkehrt & Byte-Reihenfolge beim HC595 falsch & Verkabelung Q7' prüfen \\
Letzte IDs reagieren nicht & LAST\_MASK fehlt oder falsch & Masken-Berechnung prüfen \\
\bottomrule
\end{tabularx}
\caption{Fehlerbehebung Schieberegister}
\label{tab:fehlersuche}
\end{table}

\textbf{Diagnose-Befehl:}

\begin{lstlisting}[style=shell]
pio test -d firmware -e seeed_xiao_esp32s3_e2e -f test_e2e_hw -v
\end{lstlisting}

% -----------------------------------------------------------------------------
\subsection{Weiterführende Dokumentation}

\begin{description}
\item[\code{firmware/include/hw/io\_counts.h}] SSOT für Counts/Masks
\item[\code{firmware/docs/wiring.md}] Hardware-Verdrahtung
\item[\code{firmware/docs/architecture.md}] Schichtenmodell
\item[\code{firmware/docs/debug-playbook.md}] Erweiterte Fehlerbehebung
\end{description}
